---
layout: post
title: "Optimizing Solution to Project Euler Problem 12"
date: 2015-02-02 17:19:39 -0500
comments: true
categories:
---

While workizng on the Project Euler problems, I came across one (Problem 12) that was taking a very long time to compute. In this blog post, I will go through the initial steps I took to solve the problem, followed by the steps I took to optimize the solution. Problem 12 reads:

The sequence of triangular numbers is generated by adding the natural numbers. So the 7th triangular number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Let us list the factors of the first seven triangular numbers:<br>
 1: 1<br>
 3: 1,3<br>
 6: 1,2,3,6<br>
10: 1,2,5,10<br>
15: 1,3,5,15<br>
21: 1,3,7,21<br>
28: 1,2,4,7,14,28<br>
We can see that 28 is the first triangular number to have over five divisors.
What is the value of the first triangular number to have over five hundred divisors?

<!--more-->
In order to tackle the problem, I first wrote a method to calculate the number of divisors of a given number. If the parameter was 1, the method would return 1 as the number of divisors. For all other cases, the method would search through all numbers between 1 and half of the dividend to evaluate if the dividend was evenly divisible by any of the numbers in the range. Each number in the range that divided evenly into the dividend was thus counted as a factor.
```ruby
def self.number_of_divisors(integer)
  return 1 if integer == 1
  ((1..integer/2).find_all {|divisor| integer % divisor == 0 } + [integer]).length
end
```
Next, I needed a method to iterate over triangular numbers until it found one with over 500 divisors. The method would need to keep track of the current triangular number and the current index of the triangular number, as well as calculate each triangular number. The method would also need to evaluate the number of divisors for each triangular number and return the first triangular number with over 500 divisors.

```
def triangular_number_with_over_n_divisors(desired_number_of_divisors)
  triangular_number = 0
  index = 1
  loop do
    triangular_number += index
    return triangular_number if number_of_divisors(triangular_number) > desired_number_of_divisors
    index += 1
  end
end
```
Since I was using Test Driven Development to solve the problem, my tests for this method started out with small numbers of divisors and slowly incremented to larger numbers of divisors:

```
it "returns the first triangular number to have over 1 divisor" do
  expect(triangular_number_with_over_n_divisors(1)).to eq 3
end

it "returns the first triangular number to have over 2 divisors" do
  expect(triangular_number_with_over_n_divisors(2)).to eq 6
end

it "returns the first triangular number to have over 5 divisors" do
  expect(triangular_number_with_over_n_divisors(5)).to eq 28
end

it "returns the first triangular number to have over 50 divisors" do
  expect(triangular_number_with_over_n_divisors(50)).to eq 25200
end

it "returns the first triangular number to have over 100 divisors" do
  expect(triangular_number_with_over_n_divisors(100)).to eq 73920
end
```
Once all of the above tests were passing, I tested for the first triangular number to have over 200 divisors:

```
it "returns the first triangular number to have over 200 divisors" do
  expect(triangular_number_with_over_n_divisors(200)).to eq 2031120
end
```
This was the first test to take more than 2 seconds to run. In fact, it took around 2 minutes to run. When I finally attempted to calculate the answer to the problem (requiring the number of divisors to be upped to 500), I reached a standstill. The process ran for what seemed like an eternity (1345 minutes and 37 seconds to be exact, which is roughly 22.5 hours) before returning the correct answer.

While the calculation was running, I began to try to optimize the algorithm. In order to figure out where the slowdown was occurring, I added code to print out triangular numbers each time the number of divisors incremented.

```
def triangular_number_with_over_n_divisors(desired_number_of_divisors)
  triangular_number = 0
  divisors = 0
  index = 1
  loop do
    triangular_number += index
    if number_of_divisors(triangular_number) > divisors
      divisors = number_of_divisors(triangular_number)
      puts "index: #{index}, triangular number: #{triangular_number},
      number of divisors: #{divisors}, current time: #{Time.now}"
    end
    return triangular_number if number_of_divisors(triangular_number) > desired_number_of_divisors
    index += 1
  end
end
```
With this addition, I figured out the process was held up after the 5,984th triangular number, 17,907,120, which has a total of 480 divisors. At this point, I began to explore options for optimizing the algorithm. First, I decided to examine the code to pinpoint the lines that may have been major contributors to the lag time. This led me straight to the number_of_divisors method which was running through each number between 1 and ½ of the number to check if the dividend was evenly divisible by each. For a small number, this might not be such a problem, but for the larger numbers dealt with in this exercise, this results in having to repeatedly calculate the modulo for millions of divisors. The first triangular number with over 500 divisors is over 76 million. Using the current algorithm, over 38 million moduli would need to be calculated for just the last triangular number alone. Considering over 12,000 triangular numbers would need to be looped through before reaching the first one with over 500 divisors, this algorithm was significantly slowing down the run time. What could be done in order to optimize this? Could anything be done?

Thankfully, the answer is yes! There is a handy equation to calculate the number of factors of an integer using its prime factorization. Every integer, N, is the product of prime numbers. This can be expressed using exponential notation where N is an integer, x, y, and z are prime factors of N, and a, b, and c are integer powers of the primes:

 N = x<sup>a</sup>  * y<sup>b</sup> * z<sup>c</sup> ...

Since every integer is the product of powers of prime numbers, we can use the powers of a number’s primes to find the number of possible combinations. The following equation will give us the number of factors of an integer:
(a+1)(b+1)(c+1) ...

Consider the following example:

N = 36<br>
36 has 9 factors = 1, 2, 3, 4, 6, 9, 12, 18, 36<br>

Let’s break this number down into its prime factors:<br>
36 = 2 * 18<br>
36 = 2 * 2 * 9<br>
36 = 2 * 2 * 3 * 3<br>

Now we can write the prime factorization of 36 in exponential notation:<br>
36 = 2<sup>2</sup> * 3<sup>2</sup>

Using the equation from above ((a+1)(b+1)), we can calculate the number of factors of 36 without actually having to find all of the factors:

Number of factors = (2+1) * (2+1)<br>
Number of factors = 9

I needed to figure out an efficient way to find an integer’s prime factorization so I could utilize this equation for the purposes of this Project Euler problem. I decided to create a Prime Factors module that would include a method to implement this formula. I also watched a video of the [Prime Factors kata](http://vimeo.com/7762511) to see how others have tackled this implementation. The Prime Factors module ended up containing the following methods:

```
def prime_factors_of(integer)
  prime_factors, divisor = [], 1
  while integer > 1 and divisor += 1
    prime_factors << divisor and integer/=divisor while integer % divisor == 0
    divisor = integer-1 if divisor > Math.sqrt(integer)
  end
  prime_factors
end

def counts_of_prime_factors(prime_factors)
  prime_factors.uniq.map {|prime_factor| prime_factors.count(prime_factor)}
end
```

Once I incorporated the newly created module’s methods in the original number_of_divisors method, the speed of the calculation was dramatically improved. The answer to the problem was returned in under 2 seconds!  Here’s my updated method:

```
def number_of_divisors(integer)
  return 1 if integer == 1
  counts_of_prime_factors(prime_factors_of(integer)).map {|count| count + 1}.reduce(:*)
end
```
You can find my entire solution on my [github](https://github.com/lisahamm/project_euler_tdd/blob/master/lib/problem_twelve.rb).


