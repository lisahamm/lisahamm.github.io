<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Lisa Hamm]]></title>
  <link href="http://lisahamm.github.io/atom.xml" rel="self"/>
  <link href="http://lisahamm.github.io/"/>
  <updated>2015-01-18T16:23:51-06:00</updated>
  <id>http://lisahamm.github.io/</id>
  <author>
    <name><![CDATA[Lisa Hamm]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Code Kata: Practice for Programmers]]></title>
    <link href="http://lisahamm.github.io/blog/2015/01/15/the-code-kata-practice-for-programmers/"/>
    <updated>2015-01-15T15:41:49-06:00</updated>
    <id>http://lisahamm.github.io/blog/2015/01/15/the-code-kata-practice-for-programmers</id>
    <content type="html"><![CDATA[<p>I wrote a <a href="http://www.lisahamm.com/blog/2015/01/09/the-bowling-game-kata/">blog post</a> last week about my experience pairing with my mentor on the Bowling Game Kata. I have continued to work on this kata over the last week and now have more insight into why developers do these. The word “kata” is a Japanese word for “form.” A kata is a karate exercise that is continuously repeated with the intent of making little improvements with each repetition. This concept has been brought into the software development world and is commonly referred to as a Code Kata, which is essentially a practice session for the programmer. Just as an athlete must practice her sport and a musician must practice his instrument, a developer also needs to practice her craft. Each code kata is designed to be a short exercise of which is completed daily for two weeks. The daily practice is designed to ingrain patterns into one’s mind while honing development skills.</p>

<p>I’ve discovered firsthand that a code kata is also a great way for TDD (test driven development) newbies to get a feel for the process. In this post, I’ll go through the process of completing the Bowling Game Kata in Ruby. For a complete overview of the kata, visit Uncle Bob’s website.</p>

<p>Starting with the simplest case, the first test is written for scoring a gutter game:</p>

<p>it &ldquo;can score a gutter game&rdquo; do
  bowling_game = BowlingGame.new
  20.times {bowling_game.roll(0)}
  expect(bowling_game.score).to eq 0
end</p>

<p>Running rspec at this point results in a failing test:</p>

<p>Failure/Error: 20.times {bowling_game.roll(0)}
   NoMethodError:
     undefined method `roll&#8217;</p>

<p>Now that we have a failing unit test, we can abide by Uncle Bob&rsquo;s first Law of TDD, and write code to enable this test to pass. It is also important to remember the third law of TDD, which states, &ldquo;You are not allowed to write any more production code than is sufficient to pass the one failing unit test.&rdquo;</p>

<p>def roll(pins_down)
  pins_down
end</p>

<p>def score
  0
end</p>

<p>Running rspec now results in a passing test, so we can move on to testing the next simplest case: a game in which the player knocks down one pin per roll.</p>

<p>it &ldquo;can score a simple game&rdquo; do
  bowling_game = BowlingGame.new
  20.times {bowling_game.roll(1)}
  expect(bowling_game.score).to eq 20
end
As expected, running this test results in a failure since the code is not currently storing a running total of pins knocked down. Adding the following code will allow this test to pass. Keep in mind, sticking to the rules of TDD requires one to only add enough code to result in a passing test.</p>

<p>def initialize
  @total = 0
end</p>

<p>def roll(pins_down)
  @total += pins_down
end</p>

<p>def score
  @total
end
Now that both of the tests are passing, it&rsquo;s time for some refactoring.</p>

<p>let(:bowling_game) {BowlingGame.new}</p>

<p>def roll_many(n, pins_down)
  n.times {bowling_game.roll(pins_down)}
end</p>

<p>it &ldquo;can score a gutter game&rdquo; do
  roll_many(20, 0)
  expect(bowling_game.score).to eq 0
end</p>

<p>it &ldquo;can score a simple game&rdquo; do
  roll_many(20, 1)
  expect(bowling_game.score).to eq 20
end
The next text case is for scoring a game with a spare in it.</p>

<p>it &ldquo;can score a game with a spare&rdquo; do
  2.times {bowling_game.roll(5)}
  roll_many(18, 1)
  expect(bowling_game.score).to eq 29
end
In order to score a game with a spare, we will now need a variable to keep track of the number of pins knocked down in each roll. The player will receive 10 points plus the number of pins knocked down during the first roll of the subsequent frame.</p>

<p>attr_reader :rolls
def initialize
  @rolls = []
end</p>

<p>def roll(pins_down)
  @rolls &lt;&lt; pins_down
end</p>

<p>def score
  total = 0
  i = 0
  while i &lt; rolls.length
    if rolls[i] + rolls[i+1] == 10
      total += 10 + rolls[i+2]
    else
      total += rolls[i] + rolls[i+1]
    end
    i += 2
  end
  total
end
Now that all of our tests pass, we move on to test the case of scoring a game with a strike.</p>

<p>it &ldquo;can score a game with a strike&rdquo; do
  bowling_game.roll(10)
  roll_many(18, 1)
  expect(bowling_game.score).to eq 30
end
After running rspec and watching this test fail, the score method is modified to account for the case of a strike.</p>

<p>def score
  total = 0
  i = 0
  while i &lt; rolls.length
    if rolls[i] == 10
      total += 10 + rolls[i+1] + rolls[i+2]
      i += 1
    elsif rolls[i] + rolls[i+1] == 10
      total += 10 + rolls[i+2]
      i += 2
    else
      total += rolls[i] + rolls[i+1]
      i += 2
    end
  end
  total
end
Running rspec at this point will show all of our tests currently pass. Since we are in the green, it is a good point to consider refactoring the code. We can add clearly named methods to check for a strike and a spare. We can also add methods to return the bonus points a player earns when scoring both a strike and a spare, and also the sum of the points earned in a frame without a strike or spare.</p>

<p>def score
  total = 0
  i = 0
  while i &lt; rolls.length
    if strike?(i)
      total += 10 + strike_bonus(i)
      i += 1
    elsif spare?(i)
      total += 10 + spare_bonus(i)
      i += 2
    else
      total += sum_of_balls_in_frame(i)
      i += 2
    end
  end
  total
end</p>

<p>def strike?(i)
  rolls[i] == 10
end</p>

<p>def spare?(i)
  rolls[i] + rolls[i+1] == 10
end</p>

<p>def strike_bonus(i)
  rolls[i+1] + rolls[i+2]
end</p>

<p>def spare_bonus(i)
  rolls[i+2]
end</p>

<p>def sum_of_balls_in_frame(i)
  rolls[i] + rolls[i+1]
end
These explicitly named methods facilitate reading and understanding of the code with ease for anyone who may try to digest it. Following this idea, the spec file can also be refactored to include methods for rolling a spare and rolling a strike.</p>

<p>def roll_spare
  2.times {bowling_game.roll(5)}
end</p>

<p>def roll_strike
  bowling_game.roll(10)
end
After completing this refactoring, it is now time to tackle the last test case: a perfect game of bowling. This consists of 12 strikes and results in a score of 300 points.</p>

<p>it &ldquo;can score a perfect game&rdquo; do
  12.times {roll_strike}
  expect(bowling_game.score).to eq 300
end
Running rspec now results in the following error:</p>

<p>Failure/Error: expect(bowling_game.score).to eq 300
TypeError:
  nil can&rsquo;t be coerced into Fixnum
In order to make this test pass, the score method needs a variable to keep track of the frame number. The while loop within this method needs to execute while the frame number is less than 10.</p>

<p>def score
  total = 0
  i = 0
  frame = 0
  while frame &lt; 10
    if strike?(i)
      total += 10 + strike_bonus(i)
      i += 1
    elsif spare?(i)
      total += 10 + spare_bonus(i)
      i += 2
    else
      total += sum_of_balls_in_frame(i)
      i += 2
    end
    frame += 1
  end
  total
end
You can find the complete kata on my github. After completing this kata over and over again, I am happy to report that I can now do it in close to 10 minutes and my overall agility on the keyboard has improved immensely.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Useful Keyboard Shortcuts]]></title>
    <link href="http://lisahamm.github.io/blog/2015/01/13/useful-keyboard-shortcuts/"/>
    <updated>2015-01-13T15:41:05-06:00</updated>
    <id>http://lisahamm.github.io/blog/2015/01/13/useful-keyboard-shortcuts</id>
    <content type="html"><![CDATA[<p>I’ve been working on improving the time it takes me to complete the Bowling Game Kata. One thing that has been helpful with this is learning keyboard shortcuts that facilitate easy movement throughout the text editor. I am currently coding in Sublime Text 2 on a MacBook. I found this webpage that lists several shortcuts. So far, the most useful have been:</p>

<p>-Command + Option + left or right arrow key to move from one open file to the next</p>

<p>-Command + Tab which allows you to move into another application running (this makes it easy to switch between Sublime and the Terminal)</p>

<p>-Command + Enter creates a new line (and you don’t have to be at the end of the line to utilize this)</p>

<p>-Shift + left or right arrow key will select text character by character</p>

<p>-Shift + Command + right/left arrow key will select text from cursor to end of the line</p>

<p>-Command + L selects entire line</p>

<p>-Ctrl + Command + G to find and select all cases of a word/character  (this is useful if you want to change the name of either a variable or a method that appears several times in your text)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Bowling Game Kata]]></title>
    <link href="http://lisahamm.github.io/blog/2015/01/09/the-bowling-game-kata/"/>
    <updated>2015-01-09T15:40:05-06:00</updated>
    <id>http://lisahamm.github.io/blog/2015/01/09/the-bowling-game-kata</id>
    <content type="html"><![CDATA[<p>Yesterday I sat down with my 8th Light mentor, Doug, and paired on the Bowling Game Kata and wrote it in Ruby. The general concept is to write a program capable of scoring a game of bowling and to use test driven development (TDD) in order to do so. A game of bowling is made up of 10 frames in which a player has two opportunities to knock down 10 pins. The player earns a score equal to the number of pins knocked down in each frame, but also has the opportunity to earn additional points for a spare (whatever is earned in the next roll is added to the 10 points in the frame) and a strike (points earned from the following two rolls are added to the 10 points in the frame).</p>

<p>Before attempting this kata, I had tried to learn the ropes of TDD on my own, but was having a hard time getting a feel for writing tests for “the next easiest thing.” While pairing with Doug, we went over the Three Rules of TDD which were extremely helpful to me in clarifying the process. The first rule is not to write any production code unless it is to make a failing test pass. The second rule is not to write any more of a test than is sufficient to fail. The third rule is not to write any more production code than is necessary to pass the one failing test.</p>

<p>We started with writing a test for the simplest case of a bowling game–one in which a player rolls all gutter balls. This case would result in a score of zero. After running the test and watching it fail, we added just enough production code to make it pass. The next test was for a simple game of bowling in which a player knocks down one pin each roll. The outcome of this game would be a score of 20. Once again, we ran the test, watched it fail, and added just enough production code to make it pass. We continued along like this for the case of a spare in the first frame, a strike in the first frame, and finally for the cases of a spare and strike in the tenth frame. Along the way, we did some refactoring, but only after we confirmed all tests written up to that point were passing. After finishing the kata with Doug, I felt I had such a better grasp on how to implement TDD and also learned how awesome it is. The simplicity of the code we wrote compared to what I written on my own (without using TDD) was quite a beautiful thing.</p>

<p>After we finished, Doug deleted the program and said it would be a good idea to repeat the kata over and over until I can complete it about 10 minutes. I am a huge believer in “practice makes perfect” and also had a lot of fun with this kata, so I’m excited to keeping working on it until I can meet the 10 minute goal.</p>
]]></content>
  </entry>
  
</feed>
